## 消息队列（MQ）
记录学习消息队列的的笔记，基本资料来源于https://github.com/doocs/advanced-java ，推荐阅读

### 消息队列的用处
1.消息队列主要的应用场景是解耦，异步和削峰：
解耦：当一个系统的需要调用多个系统去发送业务数据时，耦合性太强，导致新增其他系统或删除其他系统接口调用时需要修改代码，而且还需要考虑在调用过程中系统宕机之后数据应该如何处理等，这样考虑的方面就太多了，如果使用MQ，直接将数据发送到MQ，其他系统自己去消费数据，其他系统新增或取消数据调用就很方便，而且数据的维护就放在了其他系统中，减小了主系统的复杂程度。

异步：一个系统的业务逻辑需要调用其他多个系统，调用链太长，导致响应返回时间过长，体验太差，使用MQ把调用数据发送到MQ，其他系统自己去消费相关消息，主系统响应速度大大提升。

削峰：主要是在短时间的对高并发进行限制，防止系统崩溃，MQ设置最大并发量，高并发时保证多余的请求堆积在MQ中，在后面的时间再去慢慢消费，确保系统不会崩溃。

2.消息队列的优缺点：
优点：解耦，异步和削峰

缺点：
1.系统可用性降低：引入MQ导致系统增加外部依赖，宕机的可能性增加，同时需要保证MQ的高可用才能保证系统的正常运行

2.系统的复杂性提高：引入MQ需要考虑额外的问题，消息的重复消费，消费顺序，消息丢失等

3.一致性问题：多个系统消费MQ消息，但是其中一个或多个系统消费失败，导致数据出现不一致的情况。

所以，引入MQ会使系统的复杂度提升，需要考虑清楚之后再接入。

### 消息队列对比
![timewoo](https://timewoo.github.io/images/MQ1.png)

### 消息队列的高可用
#### RabbitMQ 的高可用性：RabbitMQ是基于主从来实现高可用，主要有三种模式，单机，集群和镜像集群，主要记录集群和集群镜像
1.集群（非高可用）：在多台服务器上启动多个RabbitMQ的实例，但是元数据和实际的数据只存在一台服务器上，其他实例去同步元数据和实际数据，当消费请求到达其他实例上时，实例会从元数据的实例上拉取数据，只是不同的集群，并不是分布式，也无法做到高可用，因为元数据的服务器宕机后其他实例就无法拉取数据，系统就挂了，所以这个只是为了提高消息的吞吐量。

2.镜像集群（高可用）：消息的元数据和实际数据存在于多个实例上，每个RabbitMQ节点都有一个元数据的镜像，写消息时会同步到所有的节点上，好处是可以所有节点都有全部的数据，任意节点宕机都不影响系统的正常运行，坏处是性能开销大，而且不是分布式的，无法有效拓展，因为所有数据都会同步到所有服务器上，数据量大时横向拓展无效。那么如何开启这个镜像集群模式呢？其实很简单，RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。

#### Kafka 的高可用性：
1.Kafka 一个最基本的架构认识：由多个 broker 组成，每个 broker 是一个节点；你创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。这就是天然的分布式消息队列，就是说一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。kafka是天然的分布式消息队列，就是说一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。

2.kafka 0.8以前没有HA机制（High Availability, 高可用性），任一服务器宕机后存储在上面的数据就无法读取和写入，无法做到高可用。0.8以后采用副本机制，即每个 partition 的数据都会同步到其它机器上，形成自己的多个 replica 副本，所有的replica选举一个leader来进行生产和消费，其他replica就是follower，leader会将写入的数据同步到所有的follower，如果一个节点宕机后，它在其他服务器上还有副本，可以保证系统的正常运行，而且如果leader所在服务器宕机后，其它的follower会选举出一个新的leader来保证读写的正常运行，确保高可用。

3.kafka的同步复制机制 生产者写数据时选择leader节点写入，写入磁盘之后其他follower主动从leader节点拉取数据，一旦follower拉取完数据之后就发送ack给leader，leader收到所有follower的ack之后就返回生产者写入成功。消费时会从leader节点去读数据，但是只有所有follower返回ack之后，消息才会被消费者获取到。

### 消息队列的幂等性
#### kafka消费模式: 有一个offset的概念，即每个消息写入时都分配一个offset，相当于编号，
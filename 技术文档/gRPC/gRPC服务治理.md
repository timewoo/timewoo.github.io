# gRPC服务治理
## 背景
在微服务和分布式架构中，管理服务之间的调用关系，服务的注册发现，服务间的调度，服务监控等服务治理能力越来越重要。由于微服务和分布式架构的兴盛，
会将单体服务拆分成多个微服务，每个服务为了高可用又需要部署多个实例，所以需要使用自动化工具来进行服务的集中管理和治理。  
目前服务治理大致可以分为服务注册发现、负载均衡、熔断器、网关路由、链路追踪/性能监控以及日志收集。在Java后端的技术架构中，
用来实现服务治理功能的框架和工具主要是spring cloud和K8s。后端目前主要的部署架构是通过K8s来进行服务的自动化部署，编排和扩展等功能，
服务内部采用spring cloud的组件进行服务间的注册发现，负载均衡和进程间通信。但是spring cloud和K8s在部分的服务治理功能上是有重叠的，而且services mesh
的理念的兴起，将spring cloud的部分服务治理能力直接交给K8s的呼声越来越高。  
由于gRPC是Cloud Native Computing Foundation(CNCF)基金会下的孵化项目，所以gRPC的服务治理更倾向于依赖Istio自身附带的服务治理能力。
由于后端大部分的服务还是使用的是spring cloud来进行部分服务治理，所以会对如何将gRPC服务融入现有的服务治理架构进行分析，同时分析在引入Istio的情况下
如何进行服务治理。
## 服务注册发现
在微服务架构的服务治理中，服务注册发现是较为重要的能力，容器中的服务通过注册到统一注册中心来对外提供服务地址，不需要在调用端配置硬编码的服务端地址。
在spring cloud中提供了服务注册发现相关的组件，通过外部的注册中心，比如eureka、zookeeper、nacos、consul等，来注册服务地址到注册中心，
客户端可以通过注册中心获取到服务端的地址列表，由注册中心来维护服务的地址。在gRPC中服务发现主要有下面两种方式
- 第一种方式是继续沿用spring cloud的服务注册发现机制，gRPC通过外部的注册中心来进行服务注册发现功能，但是gRPC官方本身是没有提供服务注册发现的功能实现，
  但是其设计文档提供了实现的思路，并且在不同的语言中已提供了名称解析和负载均衡地接口供开发者扩展。  
  https://github.com/grpc/grpc/blob/master/doc/naming.md   
  由于现有后端服务都是采用nacos作为注册中心来进行服务注册发现，所以部署的gRPC需要扩展名称解析器来实现nacos的注册发现，目前采用的grpc-spring-boot-starter
  (https://github.com/yidongnan/grpc-spring-boot-starter ，第三方依赖集成) 已支持nacos的注册中心，开箱即用。
  ![timewoo](https://timewoo.github.io/images/nacos-service-discovery.png)
- 第二种是不使用外部的注册中心来维护服务的注册与发现，而是使用Istio的Envoy来进行服务注册，通过Istio服务监控能力来进行服务的注册发现。  
  ![timewoo](https://timewoo.github.io/images/gRPC-service-discovery.png)  
  
为了和目前的后端服务兼容，所以还是推荐使用nacos作为服务注册中心，但是由于引用的grpc-spring-boot-starter目前是第三方维护的依赖，可能不太稳定。
## 负载均衡
关于gRPC负载均衡的介绍可以查看前一篇文档https://github.com/timewoo/timewoo.github.io/blob/master/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/gRPC/gRPC%20Load%20Balancing.md ，
在spring cloud中主要采用的Ribbon来进行负载均衡，也就是上面提到的第二种负载均衡方法，即客户端负载均衡。因此gRPC的负载均衡主要还是以下两种
- 第一种是采用客户端负载均衡的方式，gRPC本身自带了两种简单的负载均衡算法，分别是pick_first(首先选择)和round_robin(轮询)，默认是使用pick_first,
  客户端根据NameResolver解析返回的服务端地址列表来进行请求的负载均衡。这种方式的好处是实现比较简单，但是复杂均衡算法比较简单，无法使用更加智能的负载算法，
  比如根据服务端的负载，流量等情况进行请求的负载。
- 第二种是采用Istio的组件来实现负载均衡，采用这样方式的前提是使用Istio的服务发现功能，然后使用Istio的Envoy组件来进行服务间请求的负载均衡，而且
  Envoy是支持L7的负载均衡器，能够对gRPC的HTTP/2请求进行更好的负载。同时由于Envoy能够监控服务的状态，可以轻易的监控到服务流量的各项指标，还可以
  根据监控的服务状态来进行更加智能的负载均衡。
  ![timewoo](https://timewoo.github.io/images/gRPC-server-load-balancer.jpg)
## 熔断器
熔断器是为了在基础服务出现故障时使用快速失败的方式来保证请求不会长时间等待占用线程，避免故障导致服务的不可用。熔断器本质就是当请求失败的数量超过设定值后
会打开，对请求进行快速失败，同时在一段时间内会判断请求是否可用，当请求可用时会关闭熔断器。主要实现是在请求的开始和结束进行统计，在gRPC中可以使用拦截器来
自己实现，gRPC的拦截器可以在请求和响应的过程中进行自定义的逻辑处理，通过自定义拦截器来实现不同粒度的熔断器。
## 网关路由 
网关路由是在系统的边界上运行的，系统对外的唯一入口，客户端通过统一的网关来接入服务，网关层主要处理非业务的功能。在spring cloud中有专门的组件：spring cloud gateway，
可以提供安全认证，监控，限流，熔断等功能，gRPC目前是没有类似spring cloud gateway的组件，目前的部署方案是使用NGINX来作为K8s的ingress controller来进行服务的路由，
但是NGINX只有路由功能而缺乏类似安全认证，监控，限流，熔断，所以如果需要相关的功能的话，可能还是需要采用Istio的Envoy作为网关。
## 链路追踪/性能监控 
链路追踪主要是用于在分布式系统中快速定位问题，分析调用链路可以对每次调用进行收集和分析，为性能监控提供数据收集。这部分主要还是通过外部的组件来实现，下面是
几种分布式链路追踪组件的对比
![timewoo](https://timewoo.github.io/images/tracing.png)
## 日志收集
这部分的功能还是继续沿用ELK来进行日志的收集。
## 总结
由于gRPC只是一种RPC框架，并没有拥有像spring cloud一样的服务治理框架，所以对于服务治理方面要么采用云原生的服务治理组件，gRPC只关注服务本身的业务
逻辑，要么就类似spring cloud一样自己去整合相关的组件。第一种方式开发人员需要关注的点相对较少，能够更加关注于服务的开发，但是需要有完善的云原生相关的服务
部署架构，服务部署要求较高。第二种就是将服务治理的功能交给服务本身去处理，开发需要关注得相对较多，但是能够和以前的服务保证一致。上面讨论的服务治理能力只是
在后端服务的范畴内，对于前端和后端的交互还是通过NGINX来实现请求的分发。所以从上面的分析可以看出，gRPC是倾向于使用Istio来进行服务治理工作，虽然现在可以
兼容gRPC和spring cloud，但是基于云原生的服务治理还是需要有所考虑，毕竟云原生是未来的发展趋势。
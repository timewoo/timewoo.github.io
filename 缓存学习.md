## 缓存学习

## 缓存的使用用途：高性能(提升查询的效率)和高并发(提升请求的负载)。

## 缓存模型：
### redis和memcached区别：

#### 1.redis支持复杂的数据结构：
redis主要有string，hash，list，set，sorted set数据类型，string是最简单的存储结构，普通的get，set方法，做最简单的KV缓存。hash类似map的数据结构，将对象数据缓存在redis，可以操作对象中的某个字段。list有序列表，可以存储列表型数据，还可以通过lrange命令实现分页查询，类似下拉分页的效果，性能高。还可以实现简单的消息队列。set是无序的集合，自动去重，可以实现全局的redis的去重，还可以基于set进行交集，并集，差集等操作。sorted set是排序的set，可以在写入redis时写入分数，自动根据分数排序存储。

#### 2.redis原生支持集群模式：
在redis3.x版本中支持集群模式，但是memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。

#### 3.redis在小存储中性能高
由于redis时单线程工作模型，使用单核，而memcached是多核，所以平均每个核上redis存储小数据时比memcached性能更高。而在100k以上的数据，memcached的性能要高于redis。

### redis的线程模型：
redis内部使用文件事件处理器file event handler，这个文件事件处理器是单线程的，所以redis才是单线程模型。它采用 IO 多路复用机制同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。文件事件处理器包括4个结构：多个socket，IO多路复用，文件事件分派器，事件处理器（连接应答处理器，命令请求处理器，命令回复处理器），多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将产生事件的 socket 放入队列中排队，事件分派器每次从队列中取出一个 socket，根据 socket 的事件类型交给对应的事件处理器进行处理。redis客户端通信过程：
![timewoo](https://timewoo.github.io/images/redis.png)
首先，redis 服务端进程初始化的时候，会将 server socket 的 AE_READABLE 事件与连接应答处理器关联。客户端 socket01 向 redis 进程的 server socket 请求建立连接，此时 server socket 会产生一个 AE_READABLE 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该 socket 压入队列中。文件事件分派器从队列中获取 socket，交给连接应答处理器。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 AE_READABLE 事件与命令请求处理器关联。假设此时客户端发送了一个 set key value 请求，此时 redis 中的 socket01 会产生 AE_READABLE 事件，IO 多路复用程序将 socket01 压入队列，此时事件分派器从队列中获取到 socket01 产生的 AE_READABLE 事件，由于前面 socket01 的 AE_READABLE 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 key value 并在自己内存中完成 key value 的设置。操作完成后，它会将 socket01 的 AE_WRITABLE 事件与命令回复处理器关联。如果此时客户端准备好接收返回结果了，那么 redis 中的 socket01 会产生一个 AE_WRITABLE 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 ok，之后解除 socket01 的 AE_WRITABLE 事件与命令回复处理器的关联。redis完成一次通信。

### redis效率：
1.纯内存操作，2.核心是基于非阻塞的IO多路复用机制，3.C 语言实现，一般来说，C 语言实现的程序“距离”操作系统更近，执行速度相对会更快。4.单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。

### redis过期策略：
redis过期策略是定期删除和惰性删除，定期删除就是redis默认100ms就随机抽取一些设置了过期时间的key，检查是否过期，过期就删除。重点是随机抽取，并不是遍历key，这样在数据量大时能够减轻redis的压力。但是定期删除可能会导致时间到期的key没有被删除，就用到了惰性删除，就是在获取key时再去判断key是否过期，如果过期就删除数据，同时不返回数据。还是有问题就是如果有数据没有定期删除+惰性删除，就会使内存的数据堆积，消耗内存。所以需要采用内存淘汰机制，主要有：1.noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错。2.allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key。3.allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key。4.volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key。5.volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。6.volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。基本使用hashMap+双向链表的结构去实现LRU。

### redis高并发和高可用：
#### redis高并发：
redis主要依靠主从架构，一主多从，主节点用来写入数据，并且复制到从节点，从节点用来读数据。在实现高并发的同时可以使用集群，提供大容量的数据。redis主从架构：1.redis采用异步方式复制数据到从节点，redis2.8以上从节点会周期性确认每次复制的数据量。2.一个master节点可以配置多个salve节点。3.salve节点可以连接其他salve节点。4.salve节点复制时，不会阻塞master节点的正常工作。5.salve节点在复制的时候不会阻塞对当前节点的查询操作，它会用旧数据提供服务，然后在复制完成之后就会删除旧数据，加载新数据，这个时候就会停止服务。6.slave节点主要用来进行横向扩容，做读写分离，扩容的slave节点可以提高读的吞吐量。如果采用主从架构，建议开启master节点的持久化，这样就能够避免master节点宕机后复制空数据到salve节点。redis主从复制原理：当启动一个slave节点的时候，它会发送一个PSYNC命令给master节点，如果是salve节点第一次连接master节点，就会触发full resynchronization(全量复制)。此时master就会启动一个后台进程，生成一份RDB快照。同时会将从客户端新接受的写命令缓存在内存中。RDB文件生成完毕后master节点会将这个RDB发送给salve节点。salve节点会先写入本地磁盘，然后在从本地磁盘加载到内存中，接着master节点将内存中缓存的数据发送到salve节点，salve也会同步这些数据，如果salve节点和master节点断开连接之后，自动重连之后master节点只会复制salve缺失的数据。
主从复制断点续传：从redis2.8开始，如果主从复制过程中断，重新连接之后会继续从断开的地方重新复制，因为master节点会在内存中维护一个backlog，master节点和salve节点会保存一个replica offset和master run id，replica offset保存在backlog中，如果复制中断，重新连接之后就会就会从offset的位置开始继续复制，如果没有找到offset就重新开始一次resynchronization。redis可以设置无磁盘化复制，即master节点直接在内存中创建RDB，直接复制到salve中，只需要配置文件中开启repl-diskless-sync yes。salve节点不会处理过期key，master节点在删除过期key之后就会给salve节点发送del命令，同步数据。redis主从复制的完整流程：slave node 启动时，会在自己本地保存 master node 的信息，包括 master node 的host和ip，但是复制流程没开始。slave node 内部有个定时任务，每秒检查是否有新的 master node 要连接和复制，如果发现，就跟 master node 建立 socket 网络连接。然后 slave node 发送 ping 命令给 master node。如果 master 设置了 requirepass，那么 slave node 必须发送 masterauth 的口令过去进行认证。master node 第一次执行全量复制，将所有数据发给 slave node。而在后续，master node 持续将写命令，异步复制给 slave node。redis全量复制：master 执行 bgsave ，在本地生成一份 rdb 快照文件。master node 将 rdb 快照文件发送给 slave node，如果 rdb 复制时间超过 60秒（repl-timeout），那么 slave node 就会认为复制失败，可以适当调大这个参数(对于千兆网卡的机器，一般每秒传输 100MB，6G 文件，很可能超过 60s)
master node 在生成 rdb 时，会将所有新的写命令缓存在内存中，在 slave node 保存了 rdb 之后，再将新的写命令复制给 slave node。如果在复制期间，内存缓冲区持续消耗超过 64MB，或者一次性超过 256MB，那么停止复制，复制失败。slave node 接收到 rdb 之后，清空自己的旧数据，然后重新加载 rdb 到自己的内存中，同时基于旧的数据版本对外提供服务。如果 slave node 开启了 AOF，那么会立即执行 BGREWRITEAOF，重写 AOF。增量复制：如果全量复制过程中，master-slave 网络连接断掉，那么 slave 重新连接 master 时，会触发增量复制。master 直接从自己的 backlog 中获取部分丢失的数据，发送给 slave node，默认 backlog 就是 1MB。master 就是根据 slave 发送的 psync 中的 offset 来从 backlog 中获取数据的。心跳机制：主从节点互相都会发送 heartbeat 信息。master 默认每隔 10秒 发送一次 heartbeat，slave node 每隔 1秒 发送一个 heartbeat。异步复制：master 每次接收到写命令之后，先在内部写入数据，然后异步发送给 slave node。redis高可用的机制：failover 故障转移，也可以叫做主备切换，master节点在故障时会自动检测，并且将某个salve节点自动切换为master节点。
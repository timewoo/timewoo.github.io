## 缓存学习

## 缓存的使用用途：高性能(提升查询的效率)和高并发(提升请求的负载)。

## 缓存模型：
### redis和memcached区别：

#### 1.redis支持复杂的数据结构：
redis主要有string，hash，list，set，sorted set数据类型，string是最简单的存储结构，普通的get，set方法，做最简单的KV缓存。hash类似map的数据结构，将对象数据缓存在redis，可以操作对象中的某个字段。list有序列表，可以存储列表型数据，还可以通过lrange命令实现分页查询，类似下拉分页的效果，性能高。还可以实现简单的消息队列。set是无序的集合，自动去重，可以实现全局的redis的去重，还可以基于set进行交集，并集，差集等操作。sorted set是排序的set，可以在写入redis时写入分数，自动根据分数排序存储。

#### 2.redis原生支持集群模式：
在redis3.x版本中支持集群模式，但是memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。

#### 3.redis在小存储中性能高
由于redis时单线程工作模型，使用单核，而memcached是多核，所以平均每个核上redis存储小数据时比memcached性能更高。而在100k以上的数据，memcached的性能要高于redis。

### redis的线程模型：
redis内部使用文件事件处理器file event handler，这个文件事件处理器是单线程的，所以redis才是单线程模型。它采用 IO 多路复用机制同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。文件事件处理器包括4个结构：多个socket，IO多路复用，文件事件分派器，事件处理器（连接应答处理器，命令请求处理器，命令回复处理器），多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将产生事件的 socket 放入队列中排队，事件分派器每次从队列中取出一个 socket，根据 socket 的事件类型交给对应的事件处理器进行处理。redis客户端通信过程：
![timewoo](https://timewoo.github.io/images/redis.png)
首先，redis 服务端进程初始化的时候，会将 server socket 的 AE_READABLE 事件与连接应答处理器关联。客户端 socket01 向 redis 进程的 server socket 请求建立连接，此时 server socket 会产生一个 AE_READABLE 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该 socket 压入队列中。文件事件分派器从队列中获取 socket，交给连接应答处理器。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 AE_READABLE 事件与命令请求处理器关联。假设此时客户端发送了一个 set key value 请求，此时 redis 中的 socket01 会产生 AE_READABLE 事件，IO 多路复用程序将 socket01 压入队列，此时事件分派器从队列中获取到 socket01 产生的 AE_READABLE 事件，由于前面 socket01 的 AE_READABLE 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 key value 并在自己内存中完成 key value 的设置。操作完成后，它会将 socket01 的 AE_WRITABLE 事件与命令回复处理器关联。如果此时客户端准备好接收返回结果了，那么 redis 中的 socket01 会产生一个 AE_WRITABLE 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 ok，之后解除 socket01 的 AE_WRITABLE 事件与命令回复处理器的关联。redis完成一次通信。

### redis效率：
1.纯内存操作，2.核心是基于非阻塞的IO多路复用机制，3.C 语言实现，一般来说，C 语言实现的程序“距离”操作系统更近，执行速度相对会更快。4.单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。

### redis过期策略：
redis过期策略是定期删除和惰性删除，定期删除就是redis默认100ms就随机抽取一些设置了过期时间的key，检查是否过期，过期就删除。重点是随机抽取，并不是遍历key，这样在数据量大时能够减轻redis的压力。但是定期删除可能会导致时间到期的key没有被删除，就用到了惰性删除，就是在获取key时再去判断key是否过期，如果过期就删除数据，同时不返回数据。还是有问题就是如果有数据没有定期删除+惰性删除，就会使内存的数据堆积，消耗内存。所以需要采用内存淘汰机制，主要有：1.noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错。2.allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key。3.allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key。4.volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key。5.volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。6.volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。基本使用hashMap+双向链表的结构去实现LRU。

### redis高并发和高可用：
#### redis高并发：
redis主要依靠主从架构，一主多从，主节点用来写入数据，并且复制到从节点，从节点用来读数据。在实现高并发的同时可以使用集群，提供大容量的数据。redis主从架构：1.redis采用异步方式复制数据到从节点，redis2.8以上从节点会周期性确认每次复制的数据量。2.一个master节点可以配置多个salve节点。3.salve节点可以连接其他salve节点。4.salve节点复制时，不会阻塞master节点的正常工作。5.salve节点在复制的时候不会阻塞对当前节点的查询操作，它会用旧数据提供服务，然后在复制完成之后就会删除旧数据，加载新数据，这个时候就会停止服务。6.slave节点主要用来进行横向扩容，做读写分离，扩容的slave节点可以提高读的吞吐量。如果采用主从架构，建议开启master节点的持久化，这样就能够避免master节点宕机后复制空数据到salve节点。redis主从复制原理：当启动一个slave节点的时候，它会发送一个PSYNC命令给master节点，如果是salve节点第一次连接master节点，就会触发full resynchronization(全量复制)。此时master就会启动一个后台进程，生成一份RDB快照。同时会将从客户端新接受的写命令缓存在内存中。RDB文件生成完毕后master节点会将这个RDB发送给salve节点。salve节点会先写入本地磁盘，然后在从本地磁盘加载到内存中，接着master节点将内存中缓存的数据发送到salve节点，salve也会同步这些数据，如果salve节点和master节点断开连接之后，自动重连之后master节点只会复制salve缺失的数据。主从复制断点续传：从redis2.8开始，如果主从复制过程中断，重新连接之后会继续从断开的地方重新复制，因为master节点会在内存中维护一个backlog，master节点和salve节点会保存一个replica offset和master run id，replica offset保存在backlog中，如果复制中断，重新连接之后就会就会从offset的位置开始继续复制，如果没有找到offset就重新开始一次resynchronization。redis可以设置无磁盘化复制，即master节点直接在内存中创建RDB，直接复制到salve中，只需要配置文件中开启repl-diskless-sync yes。salve节点不会处理过期key，master节点在删除过期key之后就会给salve节点发送del命令，同步数据。
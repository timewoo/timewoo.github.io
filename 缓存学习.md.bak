## 缓存学习

## 缓存的使用用途：高性能(提升查询的效率)和高并发(提升请求的负载)。

## 缓存模型：
### redis和memcached区别：

#### 1.redis支持复杂的数据结构：
redis主要有string，hash，list，set，sorted set数据类型，string是最简单的存储结构，普通的get，set方法，做最简单的KV缓存。hash类似map的数据结构，将对象数据缓存在redis，可以操作对象中的某个字段。list有序列表，可以存储列表型数据，还可以通过lrange命令实现分页查询，类似下拉分页的效果，性能高。还可以实现简单的消息队列。set是无序的集合，自动去重，可以实现全局的redis的去重，还可以基于set进行交集，并集，差集等操作。sorted set是排序的set，可以在写入redis时写入分数，自动根据分数排序存储。

#### 2.redis原生支持集群模式：
在redis3.x版本中支持集群模式，但是memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。

#### 3.redis在小存储中性能高
由于redis时单线程工作模型，使用单核，而memcached是多核，所以平均每个核上redis存储小数据时比memcached性能更高。而在100k以上的数据，memcached的性能要高于redis。

### redis的线程模型：
redis内部使用文件事件处理器file event handler，这个文件事件处理器是单线程的，所以redis才是单线程模型。它采用 IO 多路复用机制同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。文件事件处理器包括4个结构：多个socket，IO多路复用，文件事件分派器，事件处理器（连接应答处理器，命令请求处理器，命令回复处理器），多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将产生事件的 socket 放入队列中排队，事件分派器每次从队列中取出一个 socket，根据 socket 的事件类型交给对应的事件处理器进行处理。redis客户端通信过程：
![timewoo](https://timewoo.github.io/images/redis.png)
首先，redis 服务端进程初始化的时候，会将 server socket 的 AE_READABLE 事件与连接应答处理器关联。客户端 socket01 向 redis 进程的 server socket 请求建立连接，此时 server socket 会产生一个 AE_READABLE 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该 socket 压入队列中。文件事件分派器从队列中获取 socket，交给连接应答处理器。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 AE_READABLE 事件与命令请求处理器关联。假设此时客户端发送了一个 set key value 请求，此时 redis 中的 socket01 会产生 AE_READABLE 事件，IO 多路复用程序将 socket01 压入队列，此时事件分派器从队列中获取到 socket01 产生的 AE_READABLE 事件，由于前面 socket01 的 AE_READABLE 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 key value 并在自己内存中完成 key value 的设置。操作完成后，它会将 socket01 的 AE_WRITABLE 事件与命令回复处理器关联。如果此时客户端准备好接收返回结果了，那么 redis 中的 socket01 会产生一个 AE_WRITABLE 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 ok，之后解除 socket01 的 AE_WRITABLE 事件与命令回复处理器的关联。redis完成一次通信。

### redis效率：
1.纯内存操作，2.核心是基于非阻塞的IO多路复用机制，3.C 语言实现，一般来说，C 语言实现的程序“距离”操作系统更近，执行速度相对会更快。4.单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。

### redis过期策略：
redis过期策略是定期删除和惰性删除，定期删除就是redis默认100ms就随机抽取一些设置了过期时间的key，检查是否过期，过期就删除。重点是随机抽取，并不是遍历key，这样在数据量大时能够减轻redis的压力。但是定期删除可能会导致时间到期的key没有被删除，就用到了惰性删除，就是在获取key时再去判断key是否过期，如果过期就删除数据，同时不返回数据。还是有问题就是如果有数据没有定期删除+惰性删除，就会使内存的数据堆积，消耗内存。所以需要采用内存淘汰机制，主要有：1.noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。2.
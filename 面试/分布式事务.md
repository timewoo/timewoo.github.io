# 分布式事务

## 分布式数据一致性理论

在单体服务架构中事务可以通过本地的事务管理来控制，但是在分布式架构中，由于事务的参与者，支持事务的服务器，资源服务器和事务管理器分别位于不同节点中，事务会调用三方服务接口，这样就无法通过本地事务管理器来控制事务的提交和回滚，因此需要分布式数据一致性方案来保证分布式架构中的数据一致性。保证数据一致性的方案有强一致性，弱一致性和最终一致性，强一致性是指在任意时刻所有节点的数据是一样的，弱一致性是指只能访问到部分变更的数据，最终一致性是指不保证任意时刻的数据一致，而是在一段时间后节点的数据最终保证一致。由于分布式需要保证数据的一致性，所以只能采用强一致性或最终一致性。CAP原则中的CP就是强一致方案来源，同时在实现强一致方案时，发现数据强一致方案需要在所有事务的执行过程中进行资源的锁定，同时在所有事务执行成功或失败后才会进行资源的释放，这样就无法提高服务的并发。

在这种场景下就提出了BASE数据最终一致性理论，BASE是BA，S和E三个特性组成，BA是指Basically Available 基本可用，允许部分服务失效保证核心服务的可用。S是指Soft State 软状态，允许系统出现中间状态，中间状态不影响系统整体的可用性。E是指Consistency 最终一致性，系统中所有的副本数据在经过一定时间后最终到达一致性状态。然后通过BASE理论有实现了一系列最终一致性方案。因此目前主流的保证分布式一致性的理论有CAP中的CP和BASE理论，通过实现这两种理论来保证分布式事务。

## 分布式事务的方案

### 数据强一致方案

分布式事务中数据强一致的方案来源于CAP中的CP，因此实现的算法主要是2PC/3PC，实现的协议的主要是XA协议，在XA协议中有两个角色，事务管理器和资源管理器，也分为两个阶段，第一阶段事务管理器给所有资源管理器发送prepare请求进行事务处理，第二阶段事务管理器根据资源管理器的事务执行情况进行事务的提交或回滚。XA协议对业务是无侵入的，主要是在数据库层面上进行管理，mysql本身就实现了相关协议。但是XA协议存在2PC的相关问题，单点问题，同步阻塞和数据不一致，单点问题是事务管理器宕机后，系统就会处于无法服务的状态。同步阻塞问题是事务管理器在二阶段宕机后资源管理器就会一直锁定资源无法释放，阻塞其他资源的获取。数据不一致问题是指当二阶段只有部分资源管理器收到commit请求时，未收到提交请求的资源管理器会阻塞，导致数据不一致。对于分布式微服务，服务之间数据调用采用的都是RPC或HTTP，无法使用同一事务管理器管理资源，同时事务管理器需要同一类数据库，但是分布式服务选择的数据库不同，最后由于强一致需要在事务的执行中锁定资源，如果事务调用过多，则会锁住很多资源同时导致数据不可用，严重影响系统性能。

最终一致性是在保证并发的性能的同时确保数据最终保证一致，由于强一致方案加锁范围大并且影响性能，因此引出了数据最终一致方案，根据BASE理论引出数据最终一致性，即允许数据在任意时刻存在数据不一致，但是最终会保证数据一致。数据最终一致性方案的实现主要有两种模式，事件通知模式和事务补偿模式。事件通知模式实现由本地消息表，可靠消息最终一致性和尽最大努力通知。事务补偿模式是TCC协议和sage协议。

事务通知模式基本上都是引入消息队列来将后续事件的通知交给消息队列来执行，确保数据的一致性，因为本地事务在发送消息成功后就提交了，所以不会长时间锁定资源，提高了并发，同时将后续操作交给消息队列，降低了耦合性。事务通知模式主要实现有本地消息表，可靠消息最终一致性和尽最大努力通知，事件消息通知最简单的思路是在本地事务中将后续操作发送到mq中，根据发送是否成功来执行本地事务提交或回滚，然后依靠mq来通知后续事务操作，这种通知的实现在mq和服务之间网络问题，导致消息发送成功但是主服务未收到响应时会回滚主服务，但是消息已发送成功，就会导致数据不一致，而且这种消息通知是同步的，当消息服务不可用时会影响系统的运行，耦合性太强。因此演变成本地消息表，本地消息表是在本地事务新建消息表，在本地事务执行时同时在消息表中存储消息信息，同时发送消息。消息发送成功则会删除消息表数据，若消息发送失败，主服务会定时扫描消息表，重新发送失败消息。这样就保证消息至少能够被发送一次。但是本地消息表的缺点是业务和消息发送还是有耦合，同时需要在本地事务中做额外的数据库操作，提高了数据库的压力，同时多余的操作会降低服务的并发。因此为了提高系统的并发，将事件消息系统独立成单独的服务，不需要维护本地的消息表，因此使用mq的事务消息来保证消息的发送。比如rocketmq的事务消息，首先向mq发送消息，标识为prepare准备状态，如果发送成功则执行本地事务，根据事务的执行发送commit或rollback，mq只有当消息标识为commit才会发送给消费者，rollback响应会删除prepare消息，同时消费者如果消费消息失败后会rocketMq会一直重试消费。rocketmq会定时轮询向消息发送方回查prepare状态的消息，若根据返回的状态(commit或rollback)来处理消息，所以rocketmq的事务消息需要发送方提供回查接口。rocketmq的事务消息将本地消息表的处理逻辑交给mq来处理，业务系统只处理业务，降低了系统的耦合性，提高了系统的并发。前面的事务消息通知都是需要保证消息可靠的发送到消费端，而有些场景运行一定程度的消息丢失，因此引出了最大努力通知，通过设置消息发送重试的次数来进行有限的消息发送，超过重试此时则不发送，这种一般在对数据的时效性要求不严的场景，比如银行通知，商户通知等。事务的消息通知主要是引入消息队列来解耦系统的事务，通过消息队列来保证事务，消息队列不可避免的就是消费的幂等性问题，因此事务消息通知需要保证消息的幂等性，如果事件本身是具有幂等性状态的，比如订单状态(下单，支付)的通知，同一订单的状态是顺序执行的，因此需要判断消息事件的顺序，首先根据时间戳来判断，消费过新消息的则丢弃老消息，如果时间戳无法判断的需要全局唯一的序列号。对于事件本身不是幂等性的，比如库存的扣减，需要将事件ID和内容持久化，消费时需要查询是否已经消费过。

事务补偿模式是指在事务的调用中由业务服务自己根据业务来设计补偿机制，来执行事务回滚的操作。事务通知模式不需要依赖于下游服务的运行结果，而事务补偿模式需要依赖于下游服务的运行结果。主流的事务补偿模式的实现是TCC和Sage协议。TCC协议是二阶段的事务补偿协议，主要分为两个阶段，一阶段是Try阶段，业务完成所有事务的检查同时预留资源。二阶段是当Try阶段中所有服务都正常，则执行Confirm操作，Confirm不做任何业务检查，只是对Try阶段的资源进行业务处理，若Try阶段由服务出现问题，则执行Cancel操作，
释放Try阶段预留的资源。比如在订单库存扣减时，Try阶段进行库存的检查和预留，Confirm进行库存的扣减，Cancel对预留的资源进行恢复。基于TCC实现的分布式事务需要将接口操作分解成Try，Confirm和Cancel，代码实现复杂度较高。Saga协议是一种纯业务补偿机制，要求每个服务调用都提供补偿接口，在事务执行中如果下游事务出现问题会根据调用链依次反向调用服务的补偿接口。Saga的补偿操作一般是不完全补偿，即补偿的操作不会完全消除改变，比如数据已经存在但是是删除状态。Saga协议在调用链较长时会导致数据不一致的状态较长。在事务补偿模式中，由于需要依赖下游的运行结果，存在网络波动的情况下需要保证接口的幂等性，可以通过唯一id或者状态机来判断是否重复执行。

![timewoo](https://timewoo.github.io/images/分布式事务.png)


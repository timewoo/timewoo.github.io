# JVM

1.JVM内存区域：

JDk1.8以前
![timewoo](https://timewoo.github.io/images/JVM1.png)

JDK1.8
![timewoo](https://timewoo.github.io/images/JVM2.png)

JVM内存中线程私有的是虚拟机栈，程序计数器和本地方法栈，线程共享的是堆，方法区和直接内存。

程序计数器：线程私有，用于记录线程执行的字节码指令位置信息，即根据程序计数器来实现代码的流程控制，同时在多线程切换时能够记录线程执行的位置。是唯一
不会出现内存溢出的内存区域，生命周期随着线程创建而创建，线程结束而死亡。

虚拟机栈：线程私有，生命周期和线程一样，是java方法执行的内存模型，方法调用的数据都是通过栈传递，虚拟机栈是由一个个栈帧组成的，每个栈帧都拥有局部变量表，
操作数栈，动态链接和方法出口信息，局部方法表存储的是编译期可知的各种数据基本类型(boolean,byte,char,short,int,float,long,double)和对象引用(
reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)，当线程请求的栈深度
超过虚拟机栈的最大深度，同时虚拟机栈的内存又不允许动态扩展时，就会抛出StackOverFlowError，如果虚拟机栈的内存耗尽，垃圾回收也没有多余内存时，就会抛出
OutOfMemoryError。

本地方法栈：线程私有，和虚拟机栈类似，只不过虚拟机栈是存储java方法，本地方法栈是存储Native方法，同样也会有局部变量表，操作数栈，动态链接和方法出口信息，
生命周期和线程一样，也会出现StackOverFlowError和OutOfMemoryError错误。

堆：是虚拟机管理的内存中最大的一块，是线程共享的内存区域，虚拟机启动时创建，存放对象的实例，几乎所有的对象实例和数组都堆中分配内存，几乎是有某些对象实例
在方法内没有返回或者只在方法内使用(未逃逸)，那对象就直接在栈上分配内存。堆又是垃圾收集器管理的主要内存区域，又叫GC堆(Garbage Collected Heap)，由于
垃圾收集器基本采用分代收集算法，所以堆又可以分为新生代和老年代，在进一步分为Eden，From Survivor,To Survivor等，在JDK1.7以前，堆分为新生代，老年代
和永久代，jdk1.8以后移除了永久代，采用元空间，元空间使用直接内存，因此Eden，From Survivor,To Survivor同意划分为新生代，对象新创建在Eden区，经过一次
垃圾收集后，对象存活会进入Survivor区，对象年龄加1，当对象经过多次垃圾手机后，年龄增加为15后，就会进入老年代。堆中是最容易出现OutOfMemoryError，当垃圾
收集器长时间执行却回收很少堆内存和创建的对象无法放入堆内存中都会引发OutOfMemoryError。

方法区：和堆一样，是线程共享的内存区域，用于存储虚拟机加载的类信息，常量，静态变量和编译后的代码，由于方法区和堆位于连续的内存区域内，所以一般把方法区
描述为堆的一个逻辑部分，但是有个别名叫非堆(Non-Heap)，方法区又叫永久代，其实方法区只是虚拟机规定的一种规范，而永久代类似于一种实现方式，在Jdk1.8以后
将方法区移除，替换为元空间，主要是由于永久代的内存大小是由JVM本身固定设置，无法调整，而元空间是使用直接内存，内存大小和系统内存有关，内存溢出的可能性
降低，能够存储更多的类信息。

运行时常量池：是在方法区内的存储编译期生成的字面量和符号引用，受到方法区内存大小限制，在Jdk1.7以前，运行时常量池包含字符串常量池，Jdk1.7时字符串常量池
被放在了堆中，剩余部分存储在运行时常量池，Jdk1.8移除了永久代改用元空间，字符串常量池还在堆中，运行时常量池还在方法区，只是方法区的实现由永久代改为元空间。

2.虚拟机对象创建：

类加载检查：虚拟机遇到new方法时，先判断参数是否在常量池中已经存在引用，然后判断引用是否已经初始化，没有则进行类加载过程。

分配内存：在类加载完成后，就需要给对象在堆中分配内存，对象所需的内存在类加载完成就可以得知，分配的方式有指针碰撞和空闲列表。指针碰撞适合于内存
规整，将内存分为两部分，一部分使用，另一部分未使用，中间用指针标记，分配内存时移动指针即可。空闲列表适合于内存不规整，列表记录内存中的可用部分，
分配内存时更新列表即可。GC收集器使用标记-清除就是不规则，标记-整理和复制就是规整的。多线程分配内存时，首先为每个线程在Eden区分配一块内存(TLAB)，
当TLAB内存不足，再使用CAS+失败重试保证堆内分配内存的原子性。

初始化0值：分配内存后，虚拟机将对象的值初始化为0值(不包括对象头)，保证对象实例不用显示的初始化赋值就可使用。

设置对象头：初始化完成后，虚拟机要设置对象头，包括对象属于那个类，如何找到类的元数据信息，对象的哈希码，对象的GC年龄代，对象的锁属性等。

执行init方法：再设置完对象头后，就会调用类的init方法使对象进行自定义的初始化，初始化赋值等。

3.对象在内存中的布局：

对象在内存中主要有对象头，实例数据和对齐填充三部分，对象头包含两部分数据，一部分是对象运行时存储的数据(哈希码，GC年龄分代，对象的锁属性等)，
一部分是类型指针，即对象指向类元数据的指针，虚拟机通过指针确定对象属于的类；实例数据存储对象的内部的数据，内部字段数据；对齐填充不是必然存在，
只是用来占位的，因为虚拟机要求对象必须是8字节的整数倍，而对象头是8字节的整数倍，为了防止对象实例数据不是8字节的整数倍，就需要增加占位数据来
补全。

4.对象的访问方式：

通过操作栈上reference数据来操作具体的堆中的对象数据，栈上的引用地址和堆上的对象的关联主要有使用句柄和直接指针，使用句柄是指reference并
不直接存储对象的地址信息，而是在堆中开辟一块内存存储句柄池，句柄中存储对象的实例数据和类型数据的地址，reference直接指向句柄的地址，这样在
对象移动后，不需要更新reference存储的地址信息，只需要更新句柄数据，因为存储的句柄的地址；直接指针是指reference直接存储对象的地址信息，不需要
向句柄一样中间有中转，节省定位的时间。

5.JVM垃圾回收：

JVM的自动内存管理主要是针对对象的内存回收和分配，最核心的部分是针对堆内存上的对象的分配和回收，java堆是垃圾回收的主要管理区域，也称为GC堆，
由于垃圾回收基本上是分代算法，所以堆又分为新生代和老年代，再细分为eden区，survivor区。
![timewoo](https://timewoo.github.io/images/JVM3.png)
eden区，survivor区属于新生代，Old Memory属于老年代，大部分情况下，新创建的对象都在eden区，当eden取快满时在进行一个新生代的GC，存活的对象
转移到survivor区，清空eden区，同时对象的年龄会加1，当对象的年龄增加到一定值时(默认是15，当设置-XX:MaxTenuringThreshold时，JVM在判断进入老年代阈值时，
会将对象根据年龄排序，然后将超过survivor区一半的年龄值和MaxTenuringThreshold取较小值作为进入老年代的阈值，即设置-XX:MaxTenuringThreshold后，进入老年的的年龄阈值不会
超过MaxTenuringThreshold)，对象就会进入老年代。当survivor from区快满时，又会进行一次GC，清空eden区和survivor from区，将存活对象放在survivor区，
然后重复上面的操作，直到survivor TO区被填满后，将对象存放进老年代。堆中对象优先分配在eden区，大对象直接进入老年代，长期存活的对象进入老年代。




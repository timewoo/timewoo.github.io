# JVM

1.JVM内存区域：

JDk1.8以前
![timewoo](https://timewoo.github.io/images/JVM1.png)

JDK1.8
![timewoo](https://timewoo.github.io/images/JVM2.png)

JVM内存中线程私有的是虚拟机栈，程序计数器和本地方法栈，线程共享的是堆，方法区和直接内存。

程序计数器：线程私有，用于记录线程执行的字节码指令位置信息，即根据程序计数器来实现代码的流程控制，同时在多线程切换时能够记录线程执行的位置。是唯一不会出现内存溢出的内存区域，生命周期随着线程创建而创建，线程结束而死亡。

虚拟机栈：线程私有，生命周期和线程一样，是java方法执行的内存模型，方法调用的数据都是通过栈传递，虚拟机栈是由一个个栈帧组成的，每个栈帧都拥有局部变量表，操作数栈，动态链接和方法出口信息，局部变量表存储的是编译期可知的各种数据基本类型(boolean,byte,char,short,int,float,long,double)和对象引用(reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)，当线程请求的栈深度超过虚拟机栈的最大深度，同时虚拟机栈的内存又不允许动态扩展时，就会抛出StackOverFlowError，如果虚拟机栈的内存耗尽，垃圾回收也没有多余内存时，就会抛出OutOfMemoryError。

本地方法栈：线程私有，和虚拟机栈类似，只不过虚拟机栈是存储java方法，本地方法栈是存储Native方法，同样也会有局部变量表，操作数栈，动态链接和方法出口信息，生命周期和线程一样，也会出现StackOverFlowError和OutOfMemoryError错误。

堆：是虚拟机管理的内存中最大的一块，是线程共享的内存区域，虚拟机启动时创建，存放对象的实例，几乎所有的对象实例和数组都在堆中分配内存，几乎是指有某些对象实例在方法内没有返回或者只在方法内使用(未逃逸)，那对象就直接在栈上分配内存。堆又是垃圾收集器管理的主要内存区域，又叫GC堆(Garbage Collected Heap)，由于垃圾收集器基本采用分代收集算法，所以堆又可以分为新生代和老年代，在进一步分为Eden，From Survivor,To Survivor等，在JDK1.7以前，堆分为新生代，老年代和永久代，jdk1.8以后移除了永久代，采用元空间，元空间使用直接内存，因此Eden，From Survivor,To Survivor统一划分为新生代，对象新创建在Eden区，经过一次垃圾收集后，对象存活会进入Survivor区，对象年龄加1，当对象经过多次垃圾收集后，年龄增加为15后，就会进入老年代。堆中是最容易出现OutOfMemoryError，当垃圾收集器长时间执行却回收很少堆内存和创建的对象无法放入堆内存中都会引发OutOfMemoryError。

方法区：和堆一样，是线程共享的内存区域，用于存储虚拟机加载的类信息，常量，静态变量和编译后的代码，由于方法区和堆位于连续的内存区域内，所以一般把方法区描述为堆的一个逻辑部分，但是有个别名叫非堆(Non-Heap)，方法区又叫永久代，其实方法区只是虚拟机规定的一种规范，而永久代类似于一种实现方式，在Jdk1.8以后将方法区移除，替换为元空间，主要是由于永久代的内存大小是由JVM本身固定设置，无法调整，而元空间是使用直接内存，内存大小和系统内存有关，内存溢出的可能性降低，能够存储更多的类信息。

运行时常量池：是在方法区内的存储编译期生成的字面量和符号引用，受到方法区内存大小限制，在Jdk1.7以前，运行时常量池包含字符串常量池，Jdk1.7时字符串常量池被放在了堆中，剩余部分存储在运行时常量池，Jdk1.8移除了永久代改用元空间，字符串常量池还在堆中，运行时常量池还在方法区，只是方法区的实现由永久代改为元空间。

2.虚拟机对象创建：

类加载检查：虚拟机遇到new方法时，先判断参数是否在常量池中已经存在引用，然后判断引用是否已经初始化，没有则进行类加载过程。

分配内存：在类加载完成后，就需要给对象在堆中分配内存，对象所需的内存在类加载完成就可以得知，分配的方式有指针碰撞和空闲列表。指针碰撞适合于内存规整，将内存分为两部分，一部分使用，另一部分未使用，中间用指针标记，分配内存时移动指针即可。空闲列表适合于内存不规整，列表记录内存中的可用部分，分配内存时更新列表即可。GC收集器使用标记-清除就是不规整，标记-整理和复制就是规整的。多线程分配内存时，首先为每个线程在Eden区分配一块内存(TLAB)，当TLAB内存不足，再使用CAS+失败重试保证堆内分配内存的原子性。

初始化0值：分配内存后，虚拟机将对象的值初始化为0值(不包括对象头)，保证对象实例不用显示的初始化赋值就可使用。

设置对象头：初始化完成后，虚拟机要设置对象头，包括对象属于那个类，如何找到类的元数据信息，对象的哈希码，对象的GC年龄代，对象的锁属性等。

执行init方法：再设置完对象头后，就会调用类的init方法使对象进行自定义的初始化，初始化赋值等。

3.对象在内存中的布局：

对象在内存中主要有对象头，实例数据和对齐填充三部分，对象头包含两部分数据，一部分是对象运行时存储的数据(哈希码，GC年龄分代，对象的锁属性等)，一部分是类型指针，即对象指向类元数据的指针，虚拟机通过指针确定对象属于的类；实例数据存储对象的内部的数据，内部字段数据；对齐填充不是必然存在，只是用来占位的，因为虚拟机要求对象必须是8字节的整数倍，而对象头是8字节的整数倍，为了防止对象实例数据不是8字节的整数倍，就需要增加占位数据来补全。

4.对象的访问方式：

通过操作栈上reference数据来操作具体的堆中的对象数据，栈上的引用地址和堆上的对象的关联主要有使用句柄和直接指针，使用句柄是指reference并不直接存储对象的地址信息，而是在堆中开辟一块内存存储句柄池，句柄中存储对象的实例数据和类型数据的地址，reference直接指向句柄的地址，这样在对象移动后，不需要更新reference存储的地址信息，只需要更新句柄数据，因为存储的句柄的地址；直接指针是指reference直接存储对象的地址信息，不需要像句柄一样中间有中转，节省定位的时间。

5.JVM垃圾回收：

JVM的自动内存管理主要是针对对象的内存回收和分配，最核心的部分是针对堆内存上的对象的分配和回收，java堆是垃圾回收的主要管理区域，也称为GC堆，由于垃圾回收基本上是分代算法，所以堆又分为新生代和老年代，再细分为eden区，survivor区。

![timewoo](https://timewoo.github.io/images/JVM3.png)

eden区和survivor区属于新生代，Old Memory属于老年代，大部分情况下，新创建的对象都在eden区，当eden区快满时再进行一个新生代的GC，存活的对象转移到survivor区，清空eden区，同时对象的年龄会加1，当对象的年龄增加到一定值时(默认是15，当设置-XX:MaxTenuringThreshold时，JVM在判断进入老年代阈值时，会将对象根据年龄排序，然后将超过survivor区一半的年龄值和MaxTenuringThreshold取较小值作为进入老年代的阈值，即设置-XX:MaxTenuringThreshold后，进入老年的的年龄阈值不会超过MaxTenuringThreshold)，对象就会进入老年代。当survivor from区快满时，又会进行一次GC，清空eden区和survivor from区，将存活对象放在survivor To区，然后重复上面的操作，直到survivor To区被填满后，将对象存放进老年代。堆中对象优先分配在eden区，大对象直接进入老年代，长期存活的对象进入老年代。

JVM的GC主要分为两大类，部分收集(Partial GC)：分为Young GC(只收集young gen区的GC)，Old GC(只收集Old gen区的GC)和Mixed GC(收集整个young gen区以及部分Old gen区的GC);整堆收集(Full GC):收集整个堆，包括young gen区，old gen区，perm gen(如果存在)等所有区域的GC。Major GC通常和full GC一样，是收集整个GC堆，但是有时候会认为是old GC。

Young GC(Minor GC)发生在eden空间已满的情况，Full GC发生在老年代空间已满、永久代空间已满的情况。

6.对象回收判断：

![timewoo](https://timewoo.github.io/images/JVM4.png)

垃圾回收前需要判断对象是否已经死亡，主要通过引用计数法和可达性分析算法，引用计数法是指给对象添加一个引用计数器，对象每次被引用则加1，当引用失效后计数器减1，计数器为0时则判断为对象死亡，可以被回收，但是主流的虚拟机都不使用这种算法，因为无法解决循环依赖的问题，即当两个对象互相引用并且没有和其他对象有引用时，这两个对象已经不会被访问，但是由于计数器不为0导致无法回收对象；可达性分析算法就是通过GC Root(虚拟机栈中的引用对象，本地方法栈中的引用对象，方法区中的类静态属性的引用对象和方法区中常量的引用对象)作为起点，遍历所有的引用，形成到GC Root的引用链，所有不在引用链上的对象都属于死亡对象，可以被回收。
引用又分为强引用(一般对象都是强引用，属于必不可少的对象，垃圾回收就算内存溢出也不会回收强引用对象，)，软引用(属于可有可无的对象，垃圾回收会在内存不足时回收该类对象，可用来实现内存敏感的高速缓存，软引用可以和引用队列关联，在对象被回收后会加入引用队列中)，弱引用(类似软引用，比软引用有更短暂的生命周期。垃圾回收只要发现弱引用对象，就会回收对象)和虚引用(虚引用不会决定对象的生命周期，虚引用在任何时刻都会被回收)。即使在可达性分析中发现没有引用的对象，也并不会马上被回收，需要经过两次标记过程，没有引用的对象会在第一次分析时被标记，并且会判断对象是否已经执行finalize方法，当对象没有覆盖finalize方法或finalize方法已经被虚拟机调用，则会等待执行回收操作，若自定义了finalize方法则会标记对象，然后将标记对象放在队列内进行二次标记，如果在执行finalize方法的过程中对象没有与引用链上的对象建立关系，就会等待执行回收操作。
常量只要没有被引用就会被回收，而类需要满足三个条件才会被回收。即类的实例都被回收，加载类的ClassLoader已经被回收和类的Class对象没有被引用(无法通过反射获取类)。

7.垃圾回收算法：

标记-清除：标记出不需要回收的对象，然后将未标记的对象全部回收，是最基础的算法，会产生效率问题和内存空间碎片化问题。

复制算法：将内存空间分为两个相同的部分，每次在一部分分配内存，当一部分内存使用完后，将存活的对象复制到另一部分，然后将这部分内存清空。

标记-整理：标记不需要回收的对象，将对象移动到连续的内存中，然后清理掉其余的内存。

分代收集：根据对象的存活周期将对象分代，根据不同代的特性采用不同的回收算法，新生代创建对象多，同时死亡对象也多，可以采用复制算法，复制少量存活对象，清理大量死亡对象，老年代存活对象多，采用标记-清除或标记-整理

分区收集：将堆空间划分为多个连续的小区间（Region），每个小区间可以单独使用（作为eden、survivor、old等区间）、单独回收（使用复制算法）。虽然在GC过程中会出现STW(应用程序停顿)，但是可以根据停顿时间来回收若干小区间，无需回收整个堆空间，降低了GC过程中产生的停顿，减少时间延迟。JDK1.7新增的G1和JDK11新增的ZGC都采用这种算法。

8.垃圾回收器：根据垃圾回收算法具体实现的回收器

Serial：串行回收器，最基本的回收器，单线程的去完成垃圾回收，同时会停止其他线程运行，直到回收完成，其他线程才能继续运行。所以需要让垃圾回收的时间尽可能的缩短，新生代采用复制算法，老年代采用标记整理。优点是简单高效，因为没有线程切换的开销，并且为了不妨碍工作线程，回收所用的时间较短。

Serial Old：Serial收集器的老年代版本，同样是单线程收集器，主要是在jdk1.5以前和Parallel Scavenge收集器一起使用，还有作为CMS收集器的后备方案。

ParNew：是Serial收集器的多线程版本，除了多线程收集垃圾外，其余行为(控制参数，回收算法，回收策略等)和Serial收集器一样。

Parallel Scavenge：也是复制算法的多线程的收集器，可以通过设置-XX:+UseParallelGC(使用Parallel收集器+老年代串行)和-XX:+UseParallelOldGC(使用Parallel收集器+老年代并行)，Parallel收集器注重的是吞吐量(使用CPU的效率)，而其他收集器更注重的是用户线程的停顿时间。新生代复制算法，老年代标记-整理。是JDK1.8默认的收集器。JDK1.8默认使用的是Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC来禁用该功能。

Parallel Old：Parallel Scavenge收集器的老年代版本，使用多线程的标记-整理。在要求吞吐量和CPU利用上，可以使用Parallel Scavenge+Parallel Old收集器。

CMS：Concurrent Mark Sweep收集器是一种以获取最小停顿时间为目标的收集器，注重用户体验。是虚拟机第一个真正意义上的并发收集器，第一次让收集线程和用户线程基本上同时工作，主要是运用在老年代的GC中，CMS是标记-清除算法，主要分为初始标记(第一次STW，暂停所有其他线程，并且记录所有存活对象，包括老年代所有GC Roots对象和被年轻代引用的老年代对象)，并发标记(同时开启GC线程和用户线程，用闭包结构记录可达对象，进行GC Root Tracing过程。遍历GC Roots记录存活对象，但是无法实时记录所有的对象，因为用户线程一直在更新引用，所以会将在并发阶段新生代晋升到老年代的对象、直接分配在老年代的对象以及老年代对象引用发生变化的对象进行标记)，重新标记(第二次STW，为了修正并发过程中由于更新引用而标记对象，会扫描整个堆空间。停顿时间会比初始标记长，比并发标记短)和并发清除(开启用户线程，同时GC线程对未标记的区域进行清理，由于用户线程还在运行，所以会产生部分浮动垃圾留待下次GC处理)。优点是并发收集和低停顿，但是缺点是对CPU资源敏感，无法处理浮动数据以及使用标记-清除算法会产生大量空间碎片。

G1：是服务器级别的垃圾收集器，针对多处理器和大内存的服务器，满足GC停顿时间和高吞吐量。特点是并行与并发(使用多个CPU来缩短停顿时间，通过并发能让GC线程和用户线程同时执行，不用阻塞)，分代收集，空间整合(G1整体上基于标记-整理，局部上基于复制算法)和可预测的停顿(建立可预测的停顿时间模型，可以指定在特定毫秒内停顿)。流程是初始标记（第一次STW，记录所有GC Root对象，同时执行一次young gc），并发标记（标记存活对象，并发执行），最终标记（第二次STW，修正并发标记中记录的对象）和筛选回收（并发清理）。G1收集器会在后台维护一个优先队列，根据允许收集的时间来回收价值最大的Region，这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

ZGC：

CMS在JDK9被标记为弃用，JDK14被删除，默认使用G1作为新生代和老年代的垃圾回收器。

9.类的加载过程：

类的生命周期是加载->连接(验证，准备，解析)->初始化->使用->卸载，类加载过程是加载->连接->初始化，连接又分为验证->准备->解析

加载：类加载的第一步，主要完成通过全类名获取定义此类的二进制字节流，将字节流的所代表的静态存储结果转换为元空间的运行时数据结构，在内存中生成一个代表该类的Class对象，作为方法区数据的入口。一个非数组类的加载阶段(加载阶段获取二进制字节流的动作)是可控性最强的阶段，可以在这一阶段通过自定义的类加载器去控制获取流的方式(重写类加载器的loadClass方法)，数组类型是直接通过虚拟机创建，不经过类加载器。加载阶段和连接阶段是交叉进行的，并不是严格的先后顺序。

连接：分为验证，准备和解析，验证主要是文件格式验证(验证文件是否符合class文件的规范，版本号是否符合，常量池的常量的类型是否支持等)，元数据验证(对字节码的描述信息进行语义分析，保证描述的信息符合java语言规范，是否有父类，是否继承了不允许继承的类即final修饰的类等)，字节码验证(通过数据流和控制流分析，确保程序的语义是合法的)和符号引用验证(确保解析动作可以正确执行)；准备阶段是为类变量分配内存并且设置类变量的初始值，即在元空间分配内存，这个阶段只会分配静态变量，实例变量在对象实例化时在堆内分配，设置的初始值都是数据类型的默认值，即static int value = 111，准备阶段的value值的0，初始化时才会赋值111，但是static final int value = 111，准备阶段value就是111；解析阶段就是虚拟机将常量池内的符号引用替换为直接引用的过程，能够得到类，字段或方法在内存中的指针或者偏移量，主要针对类或接口，字段，类方法，接口方法，方法类型，方法句柄和调用限定符7类符号引用。

初始化：类加载的最后一步，初始化是执行类构造器的<client()>方法的过程，虚拟机会保证方法的线程安全，由于<client()>方法是带锁线程安全，所以在多线程下的类初始化可能引起死锁。通过new(创建对象)，get static(访问类的静态变量)，put static(对类的静态变量赋值)或invoke static(调用类的静态方法)会对类初始化；对类使用反射方法(Class.forName()等)时会初始化没有初始化过的类；初始化类时会先初始化没有初始化过的父类；当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类；MethodHandle和VarHandle可以看作是轻量级的反射调用机制，而要想使用这2个调用， 就必须先使用findStaticVarHandle来初始化要调用的类；当接口使用JDK1.8的default修饰符，如果接口的实现类发生初始化，那接口在实现类之前初始化。

卸载：内存中类的Class对象被GC，即类的所有实例对象都被GC，该类没有其他地方引用以及该类的类加载器实例被GC都会引起类卸载。一般JDK自带的类加载器不会被卸载，只有自定义的类加载器可能被卸载。

10.类加载器：

JVM内置的加载器是BootstrapClassLoader(启动类加载器，是最顶层的类加载器，由C++实现，主要负责加载JDK的lib目录下的jar包和类，或者是被-Xbootclasspath参数指定的路径中的所有类)，ExtensionClassLoader(扩展类加载器，主要负责加载JDK的/lib/ext目录下的jar包或类，或者是被java.ext.dirs系统变量指定的路径下的包)，AppClassLoader(应用程序类加载器，负责加载当前应用classpath下的所有jar包和类)，这三个类自顶向下，自定义的类加载器都是这三个类的子类。

双亲委派模型：双亲委派是指在类加载过程中，先判断类是否已经加载，已经加载的类直接返回，未加载的类在加载时会优先将加载请求委派给该类加载器的父类加载器的loadClass()方法处理，如果该类加载器没有父类加载器，则默认启动BootstrapClassloader作为父类加载器，即最终所有的类加载器都需要调用顶层的BootstrapClassLoader加载器，只有在父类无法加载该类的情况下，该类加载器才会尝试加载。

```java

/**
 * ClassLoder的加载方法，默认调用
 */
public Class<?> loadClass(String name) throws ClassNotFoundException {
    return loadClass(name, false);
}

/**
 * ClassLoader
 */
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // 首先判断类是否加载过，加载过直接返回类
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    // 判断父类加载器是否为null，父类加载器调用加载方法
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // 父类加载器加载请求失败
                }

                if (c == null) {
                    // 父类加载完成，自己尝试加载
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // 记录统计数据
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
```
双亲委派模型保证了Java程序稳定运行，可以避免类的重复加载，即JVM将不同类加载器加载的同一个类文件产生的类视为不同的类，当多个类加载同一个类时，如果没有双亲委派就会出现多个重复类，双亲委派保证加载的相同的类在JVM中只存在一份。也可以保证java的核心Api不被篡改，即和Java核心类同名的自定义类(String,Object)只会加载核心类，如果没有双亲委派模型，自定义和Java核心类相同的类名的类时，JVM就会加载自定义的类，出现多个同名的核心类，因为是不同的类加载器加载的，就会造成混乱。自定义类加载器时需要继承ClassLoader类，并且重写findClass()方法自定义类加载实现，但是这时候类加载默认就是双亲委派，如果不想使用双亲委派，则还需要重写loadClass()方法，去掉双亲委派的逻辑。

类的加载顺序先加载基类，然后加载静态修饰的方法，变量，代码块，按照代码顺序加载。然后加载普通变量，代码块，按照代码顺序加载，最后加载构造方法。


11.JVM参数：

-Xms和-Xmx：设置最小堆内存和最大堆内存，-Xms2G -Xms5G

新生代内存设置：-XX:NewSize=256m -XX:MaxNewSize=1024m，设置最小和最大新生代内存，或者-Xmn256m，直接分配新生代内存。

元空间(JDK1.7方法区)内存设置：-XX:MetaspaceSize=N(设置元空间初始大小，方法区是-XX:PermSize=N)和-XX:MaxMetaspaceSize=N(设置元空间最大大小,方法区是-XX:MaxPermSize=N)

设置垃圾回收器：-XX:+UseSerialGC(串行),-XX:+UseParallelGC(并行),-XX:+UseParNewGC(CMS)和-XX:+UseG1GC(G1)




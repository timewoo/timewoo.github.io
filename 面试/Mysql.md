# Mysql

1.Mysql存储引擎：

MyISAM在5.5之前是mysql默认的存储引擎，性能很快，同时提供大量的特性，包括全文索引，压缩，空间函数等，但是MyISAM不支持事务和行级锁，同时在
mysql崩溃后无法安全的恢复，然后在5.5之后引入了InnoDB(事务性数据库引擎)，InnoDB默认为mysql的存储引擎。大部分情况下mysql都选择InnoDB，但是
如果不考虑数据崩溃和事务，同时需要高密集的读操作，可以尝试MyISAM，但是一般都需要考虑这些场景。

区别：InnoDB支持行锁(row-level)和表锁，默认是行锁，MyISAM只支持表锁；MyISAM强调是性能，每次查询都是原子性，所以其执行速度比InnoDB快，但是不支持事务，
InnoDB支持事务和外键，具有事务回滚，回滚和崩溃修复能力的事务安全型表；MyISAM不支持外键，InnoDB支持外键；InnoDB支持MVCC，用来应对高并发。

2.Mysql字符集和校对规则：

字符集是指一种从二进制编码到某类字符符号的映射，校对规则是指在某种字符集下的排序规则，mysql采用类似继承的方式指定字符集，即表在没有指定字符集的情况下
模式使用数据库的字符集。

3.索引：

mysql的索引存储的数据结构主要有BTree索引和哈希索引。哈希索引底层是哈希表，适用于对于单条数据的查询，查询很快，其他场景一般使用BTree索引，BTree索引
使用B树中的B+Tree，MyISAM中的BTree索引实现是非聚簇索引，即B+Tree的叶子节点data域中存放的是数据记录的地址，在索引检索时，首先按照B+Tree搜索算法
搜索索引，如果key存在，则取出节点的data域的值，然后再通过data的地址值找到对应的数据。InnoDB主索引采用聚簇索引，因为InnoDB数据文件本身就是索引文件，
MyISAM中数据和索引是分开的，而InnoDB的数据本身按照B+Tree组织成一个索引结构，节点的data域存放的就是数据本身，索引key是数据表的主键，因此InnoDB的数据本身就是主索引，
其他索引称为辅助索引，辅助索引是非聚簇索引，辅助索引的节点data域存放的是数据的主键，InnoDB在根据主索引搜索时，直接找到主键的节点，取出data域的数据即可，而根据辅助索引搜索
时，会先找到主键的值，然后再在主索引上找到数据，因此，表的主键字段不易过长，也不建议使用非单调的字段作为主键，避免主索引频繁分裂。其实聚簇索引和非聚簇索引
与mysql的存储引擎并没有强关联，MyISAM的索引使用非聚簇索引，InnoDB主索引使用聚簇索引，辅助索引使用非聚簇索引。

4.缓存：

mysql可以在my.cnf中加入配置来开启缓存，在相同查询条件以及数据情况下，会直接返回缓存中的数据，相同条件包括查询条件，查询数据库，客户端的版本协议等一些
可能会影响结果的条件，因此在不同字符上会导致缓存不命中，同时查询中包含用户自定义函数，存储函数，用户变量，临时表，MySQL的系统表，查询结果也不会被缓存。
当缓存建立后，mysql缓存查询系统会跟踪查询中涉及的每张表，如果表结构或数据发生变化，缓存也会失效。虽然缓存能够提升查询效率，但是也带来了额外开销，每次
查询都需要进行缓存操作，缓存失效后还需要销毁，得不偿失，mysql8去掉了缓存的设置。

5.事务：

事务是指逻辑上的一组操作，要么都成功，有么都失败。事务拥有的A(Atomicity,原子性，事务是最小的执行单位，不允许分割，事务的原子性保证动作要么全部完成，
要么全部失败)C(Consistency,一致性，执行事务后，数据库从一个正确状态转到另一个正确状态)I(Isolation,隔离性，并发访问数据库时，一个用户的事务不会被
其他事务所干扰，各并发事务之间数据库是相互独立的)D(Durability,持久性，一个事务被提交后，它对数据库数据的改变是持久的，即使数据库发生故障也不会对其有
影响)特性，由于多线程比较常见，所以并发事务会造成脏读，修改丢失，不可重复读和幻读。脏读(Dirty read)是指一个事务在修改数据还未提交时，另一个事务访问
到了还未提交的数据，由于数据未提交，后续可能发生回滚，所以另一个事务读的就是脏数据；修改丢失(Lost to modify)是指在并发事务中，一个事务修改了另一个
事务的提交数据，导致事务的修改被丢失了；不可重复读(Unrepeatableread)是指一个事务多次访问同一数据，在访问过程中另一个事务修改了相关数据，导致事务
多次访问同一数据得到的结果不一样；幻读(Phantom read)类似不可重复读，是指在一个事务中多次读取数据时另一个事务插入或删除了相关数据，导致事务多次访问
获取的数据数量不一致。幻读和不可重复读的区别是一个是多次访问发现数据有删除或新增，一个是多次访问同一数据发现数据被修改。

为了应对并发事务之间出现的问题，sql标准设置了四种事务隔离级别，读取未提交，读取已提交，可重复读，可串行化，读取未提交(READ-UNCOMMITTED)是最低的隔离级别，
允许读取到事务未提交的数据变更，可能导致脏读，幻读，不可重复读；读取已提交(READ-COMMITTED)允许读取到事务已经提交的数据变更，可能导致幻读和不可重复读。
可重复读(REPEATABLE-READ)是指对同一个字段的多次读取结果都是一致的，除非数据本身被自身的事务修改，可能导致幻读；可串行化(SERIALIZABLE)是最高级别的隔离，
是完全服从ACID原则，就是事务之间的顺序是串行化的，可以防止脏读，幻读和不可重复读。mysql的InnoDB默认的事务隔离级别是可重复读，但是InnoDB实现可重复读的
同时可以避免幻读，主要实现原理根据sql的查询方式不一样，直接select是通过mvcc来通过快照读来实现一个事务中的查询都是在快照中获取，不会被其他事务操作影响，
通过select for update查询时主要是通过使用Next-key Lock算法，即通过record+gap 锁定一个范围，包含记录本身，一般是锁定一个范围，其他事务在需要修改这个范围内的数据时会等待，
所以可以解决幻读问题，即mysql的可重复读的实现已到达sql隔离的可串行化标准，还可以。由于隔离级别越高，需要加锁越多，所以大部分数据库的隔离级别是读取提交内容。
InnoDB虽然可重复读可以避免幻读，但是在分布式的情况下无法做到事务隔离，所以选用串行化隔离。

6.mysql锁：

MyISAM采用表级锁(table-level locking)，InnoDB采用行级锁(row-level locking)和表级锁，默认为行级锁。表级锁是mysql中粒度最大的一种锁，是对当前整张表进行加锁，
实现简单，资源消耗较少，加锁比较快，也不会出现死锁，但是触发锁冲突的概率最高，并发度最低。行级锁是mysql粒度最小的一种锁，只是针对当前操作的行进行加锁，行级锁
能够大大减少锁冲突的概率，并发度最高，但是加锁的开销也大，加锁也慢，容易出现死锁。InnoDB的行锁算法主要有Record lock(单行索引记录上的加锁)，Gap lock(间隙锁，
锁定的一个范围内的索引记录，不包括查询的记录)和Next-key lock(record+gap，锁定一个范围内的索引记录，包括查询的记录本身)。InnoDB默认查询使用的是next-key lock，
但是在查询的是唯一索引时会将next-key lock降级为record lock，Gap间隙锁是为了阻止多个事务将记录插入同一范围，或在同一范围删除记录，防止幻读。可以在mysql中设置
事务隔离级别为RC，或者设置innodb_locks_unsafe_for_binlog为1来显示的关闭Gap锁。

7.mvcc(多版本控制)：

mvcc是指多版本控制，是用来提升数据库并发的一种技术，在早期的数据库中，只要涉及到写操作都会加锁，引入多版本控制后，只有写写操作才会加锁，这样就提升了InnoDB的并发度，
InnoDB在数据更新时将旧数据存放在undo log日志文件中，通过undo log日志可以找到旧数据给用户读(按照隔离的级别，有些读请求只能看到旧数据)，同时可以在回滚的时候根据
undo log日志来覆盖数据，同时在InnoDB内部会记录一个全局的活跃读写的事务组，用来判断事务之间的可见性。mvcc可以通过乐观锁和悲观锁来实现，同时mvcc只能在读取已提交和
可重复读的隔离级别下工作。

在mysql中，会维护一个全局的trx_sys事务链，是一个链表结构，保存的都是没有提交的事务，当事务提交之后就会从trx_sys事务链中删除。
read view(读视图)类似一个事务的快照存储结构，主要是用来做可见性判断的，保存的是对本事务不可见的其他活跃事务，主要存储low_limit_id(当前事务链中最大的事务编号+1)，
up_limit_id(当前事务链中最小的事务编号)和trx_ids(当前事务链中的事务编号集合)，read View存储的是当前所有的活跃事务编号，即未提交的事务的集合，但是不包含当前事务。
InnoDB在不同隔离级别下生成read view的时机也不同，在可重复读级别下，事务在begin/start transaction之后的第一条select语句后会创建一个read view，将当前的活跃事务
存储起来，在整个事务中都使用这一个read view，而在读取已提交级别下，事务的所有查询语句都会重新创建一个read view，将原来的read view重置。因此在读取提交级别下，
read view内的活跃事务结合可能有变化，导致出现幻读和不可重复读出现。undo log是InnoDB实现mvcc事务的主要组成，当数据发生变更时，会在undo log文件中记录老版本的数据，
5.6之前默认存储在系统表空间中(ibdata)，5.6之后可以使用独立的Undo表空间。旧数据的事务需要读取数据时，当前行不可见的情形下需要根据undo链来找到满足可见性的数据记录，
当undo链很长时可能会比较耗时。INSERT操作在事务提交前对当前事务可见，而且只有在事务回滚时才需要，所以产生undo日志在事务提交后可以删除，InnoDB归为insert_log,
而对于UPDATE和DELETE需要维护多版本的信息，不仅在事务回滚时需要，而且在读一致性也需要，只有在read view不需要该日志记录时，才会被purge日志，因此在InnoDB这两种操作
产生的undo日志被归为update_undo。InnoDB会在每行数据添加三个隐藏字段，DB_TRX_ID(6字节的事务id，标识最近一次修改(insert|update)的数据的事务id)，DB_ROLL_PTR(7字节
undo log日志中回滚段的记录，即如何回滚的sql语句)，DB_ROW_ID(递增的字段，当未指定主键或唯一索引时，默认根据字段生成聚簇索引)

mvcc的实现主要通过可见性算法，即比较DB_TRX_ID和read view中low_limit_id，up_limit_id的大小，当DB_TRX_ID<up_limit_id，说明数据的修改事务在当前事务之前已经提交，
则当前事务直接获取数据，当DB_TRX_ID>=low_limit_id，说明数据的修改事务在当前事务之后开启，在当前事务内提交，读取的数据被其他事务修改，数据不可见，就会在undo log日志
去寻找当前数据的旧版本数据，如果旧版本数据的事务id<up_limit_id，则获取这个事务id的数据，当up_limit_id<=DB_TRX_ID<low_limit_id，则会遍历read view中的trx_ids，
如果DB_TRX_ID不在trx_ids集合内，说明事务已经提交了，则数据是可见的，如果DB_TRX_ID在trx_ids集合内，并且和当前事务id相同的话就是当前事务修改的，所以也是可见的，如果
DB_TRX_ID在trx_ids集合内并且不和当前事务id一致，则有未提交的事务，数据不可见。

8.索引：

索引能够大大加快数据检索的速度，帮助服务器避免排序和临时表，将随机IO变为顺序IO，可以加快表和表之间的关联，创建唯一索引可以保证数据的唯一性。但是给表加索引并不一定可以
加快查询效率，因为对表中数据新增，修改和删除时，需要额外维护索引，索引需要占用额外的的物理空间，同时创建索引和维护索引需要耗费额外时间，所以不能随便建立对索引。

mysql中索引主要有两种，哈希索引和BTree索引，哈希索引底层是哈希表，在单条数据查询时效率较高，但是哈希索引不支持顺序和范围查找。BTree索引在不同的存储引擎实现不一样，一般
都是将BTree实现为B+Tree，原因是BTree所有的节点都包含索引key和data域，B+Tree树只有叶子节点存放key和data域，其他节点只存放索引key；BTree的叶子节点是独立的，B+Tree
的叶子节点有一条引用链指向和它相邻的叶子节点；BTree的搜索位置不确定，可能匹配到任意节点，而B+Tree最后匹配的都是叶子节点。
在MyISAM中主要是B+Tree的叶子节点的data域存放的是数据记录的地址，在索引检索时，首先按照B+Tree的搜索算法查询索引，key存在则取出对应的data域的数据地址，然后通过地址去查询对应数据的值，
这个称为非聚簇索引；在InnoDB中数据文件和索引文件是一体的，按照B+Tree组织成一个结构，叶子节点data域保存完整的数据记录，用主键作为索引的key的是主索引，也成为聚簇索引，
而用其他字段作为索引的称为辅助索引，叶子节点的data域存储的是主键的值，然后再根据主键值查询主索引。因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，
这样会造成主索引频繁分裂。

索引按照存储索引key类型主要分为主键索引和辅助索引，主键索引(Primary key)是指使用主键作为索引key，主键索引又称为聚簇索引，在InnoDB中，当没有显示的指定主键时，会
判断是否有唯一索引的字段，如果有，就将该字段的默认为主键，否则就会自动创建一个6byte的自增主键。辅助索引是指索引的叶子节点的data域存储的是主键，根据索引key获取记录
主键，然后再去主键索引查询具体记录，唯一索引，普通索引，前缀索引，全文索引等属于辅助索引，唯一索引是指作为索引的字段不能出现重复，但是允许null值，一张表可以创建多个唯一索引，
唯一索引一般是为了保证字段值的唯一性，并不是为了查询效率。普通索引是一般的索引，允许null值和重复值，一张表可以创建多个普通索引，主要是为了查询效率。前缀索引是指对
字符串类型字段，只对前几个字符创建索引，索引数据小。全文索引主要是为大文本数据的关键字建立索引，mysql 5.6之前只有MyISAM支持全文索引，5.6之后InnoDB也支持。
覆盖索引是指索引内包含所有需要查询的字段的值，由于在使用辅助索引需要查询两次表，所以覆盖索引在节点存储的key是要查询的字段值，比如对(username,age)建立覆盖索引，则
索引的key是包含username和age的两个字段的值，当根据key查询到索引位置时，可以直接返回覆盖索引包含的字段值，不需要在根据叶子节点的主键值再去查询主索引，提高查询效率。
索引又可以分为聚簇索引和非聚簇索引，主要是看B+Tree的叶子节点data存储的是数据类型，存储的是记录的就是聚簇索引，例如主键索引，其他的则是非聚簇索引，例如MyISAM存储
记录的地址，辅助索引存储主键的值。聚簇索引缺点是需要依赖于有序的数据，因为B+Tree是多路的平衡树，如果索引不是有序的，就需要在插入时排序，如果索引很长，则插入或查找
就会很慢，同时更新代价大。非聚簇索引缺点也是需要依赖于有序数据，而且获取的时主键的值，可能需要进行回表(二次查询)。

索引主要依靠mysql的存储格式，mysql存储数据的基本格式是页。

![timewoo](https://timewoo.github.io/images/mysql.jpg)

![timewoo](https://timewoo.github.io/images/mysql1.jpg)

mysql将数据存储为多个页，每个数据页可以组成一个双向的链表，每个数据页存储的记录内部又形成一个单向链表，由于数据页中的记录按照主键排序，所以会将内部的记录分成一个个组，
然后将每组的最大记录按照顺序存储在一起，形成页目录，在通过主键查询记录时先遍历数据页获取记录存储的数据页，然后通过对页目录进行二分法查询对应记录的所存储的槽，也就是分组，
再遍历槽中的记录获取指定记录。如果不是主键查询的话，在获取记录所在的数据页后，只能遍历数据页中的所有记录来获取指定记录，查询时间很慢。时间复杂度是O(n)。
由于默认数据页是无序的，所以需要遍历查询数据页才能获取记录存储的位置，索引主要是对数据页排序，查询时能够快速找到对应的数据页。索引使用B+Tree结构，所有节点的结构都是数据页，
但是非叶子节点存储的是索引key和对应的子节点的数据页标识，只有在叶子节点存储索引key和data域记录，数据页内部是经过排序的，所以能够根据索引key快速找到对应的叶子数据页，再获取到
叶子数据页上的准确数据。

![timewoo](https://timewoo.github.io/images/mysql2.jpg)

![timewoo](https://timewoo.github.io/images/mysql3.jpg)

最左前缀原则是在创建联合索引，即多个字段以一定的顺序生成索引时，例如(username,age)，在查询语句中出现的查询条件精确匹配索引的左边一列或多列，那么可以命中索引，
即where username = xxx and age = xxx和where username = xxx可以命中索引，但是where age = xxx不能命中索引。如果查询条件全部匹配但是顺序不一致，查询引擎会
自动优化为匹配索引的顺序，即where age = xxx and username = xxx，可以命中索引。所以在创建联合索引时，应该考虑将使用频繁的字段放在左边。同时应该避免冗余索引，
即是索引的功能相同，能够命中就肯定能命中，比如(username,age)和(username)都能命中，所以需要尽量扩展而不是创建新索引。

索引应该在需要经常搜索的字段上创建，比如where后面。在经常排序的字段上，因为索引已经排过序了，可以加快排序的时间。避免在索引字段上使用函数，这样会是索引无法命中。
在表关联字段上加索引可以加快连接速度。可以使用自增字段作为主键索引。索引字段值尽量不设置为null，虽然设置为null不影响索引的效率，但是null需要更多的空间存储且无法参与
某些运算，对于冗余索引尽量删除，减少性能消耗。尽可能建立联合索引而不是单个索引。







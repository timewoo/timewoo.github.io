# java基础学习
## 对象
###数据存储

程序运行时的数据主要存储在5个地方：

1.寄存器(Registers)：最快的存储区域，位于 CPU 内部(大多数微处理器芯片都有额外的高速缓冲存储器，但这是按照传统存储器而不是寄存器。)。
然而，寄存器的数量十分有限，所以寄存器根据需求进行分配。我们对其没有直接的控制权，也无法在自己的程序里找到寄存器存在的踪迹
（另一方面，C/C++ 允许开发者向编译器建议寄存器的分配）

2.栈内存(Stack)：存在于常规内存 RAM（随机访问存储器，Random Access Memory）区域中，可通过栈指针获得处理器的直接支持。栈指针下移分配内存，
上移释放内存。这是一种仅次于寄存器的非常快速有效的分配存储方式。创建程序时，Java 系统必须知道栈内保存的所有项的生命周期。
这种约束限制了程序的灵活性。因此，虽然在栈内存上存在一些 Java 数据（如对象引用），但 Java 对象本身的数据却是保存在堆内存的。

3.堆内存(Heap)：这是一种通用的内存池（也在 RAM 区域），所有 Java 对象都存在于其中。与栈内存不同，编译器不需要知道对象必须在堆内存上停留多长时间。
因此，用堆内存保存数据更具灵活性。创建一个对象时，只需用 new 命令实例化对象即可，当执行代码时，会自动在堆中进行内存分配。这种灵活性是有代价的：
分配和清理堆内存要比栈内存需要更多的时间（如果可以用 Java 在栈内存上创建对象，就像在 C++ 中那样的话）。
随着时间的推移，Java 的堆内存分配机制现在已经非常快，因此这不是一个值得关心的问题了。

4.常量存储(Constant storage):常量值通常直接放在程序代码中，因为它们永远不会改变。如需严格保护，
可考虑将它们置于只读存储器 ROM （只读存储器，Read Only Memory）中(一个例子是字符串常量池。所有文字字符串和字符串值常量表达式都会自动放入特殊的静态存储中。)

5.非RAM存储(Non-RAM storage):数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。两个主要的例子：
（1）序列化对象：对象被转换为字节流，通常被发送到另一台机器；（2）持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在。
这些存储的方式都是将对象转存于另一个介质中，并在需要时恢复成常规的、基于 RAM 的对象。Java 为轻量级持久化提供了支持。
而诸如 JDBC 和 Hibernate 这些类库为使用数据库存储和检索对象信息提供了更复杂的支持。

### 基础类型的存储
基础类型直接存储值，并置于栈内存中，效率更高。java确定了每种基本类型的内存占用大小。基本类型对应的包装类存储在堆内存中。
![timewoo](https://timewoo.github.io/images/java基础类型.png)

### java值传递？引用传递？

值传递：调用函数时将实际的参数值复制一份，函数内参数的改变不影响原来的值。

引用传递：调用函数时将实际参数的引用地址复制一份，由于指向相同的引用地址，函数内参数的改变会影响原来的值。

java中的参数传递：基础类型的变量值直接存储在变量中，引用类型的存储的只是指向对象的内存地址。java中参数的传递是将传递的参数复制一份，
类似副本，基础类型直接复制一份变量值，引用类型也复制一份对象的引用，引用同一个对象。所以改变基础类型时只是改变副本的值，改变引用类型时
由于指向同一个对象，会改变对象的值。而一般在函数中对String类型赋值时不会改变原String参数的值，是因为String赋值时会新创建一个对象，并
将引用指向新对象的地址，然后原值不会改变。
```
第一个例子：基本类型
void foo(int value) {
    value = 100;
}
foo(num); // num 没有被改变

第二个例子：没有提供改变自身方法的引用类型
void foo(String text) {
    text = "windows";
}
foo(str); // str 也没有被改变

第三个例子：提供了改变自身方法的引用类型
StringBuilder sb = new StringBuilder("iphone");
void foo(StringBuilder builder) {
    builder.append("4");
}
foo(sb); // sb 被改变了，变成了"iphone4"。

第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。
StringBuilder sb = new StringBuilder("iphone");
void foo(StringBuilder builder) {
    builder = new StringBuilder("ipad");
}
foo(sb); // sb 没有被改变，还是 "iphone"。
```
赋值运算符 = 在基础类型中时改变值，而对象类型中只是赋予对象的引用地址。

### java运算符
java递增和递减采用前缀(++a,--a)和后缀(a++,a--),前缀会先执行计算后返回值，后缀会先返回值后计算。

java比较运算符(==,!=)：基础类型比较的是值，引用类型比较的是对象的引用地址。
```
Integer a = 47;
Integer b = 47;
System.out.println(a==b);//true
```
Integer类型直接赋值会调用包装类型的自动装箱，调用Integer的valueOf方法
```
public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
}
```
IntegerCache的上下限[-128,127],所以当Integer赋值在这个返回内，相同的赋值会返回相同的引用对象。不在范围内会返回不同的引用。
所以比较对象类型时尽量使用equals。

### java垃圾回收

1.判断对象是否存活的方法：

引用计数法：为每个创建的对象分配一个引用计数器，判断计数器为0意味着对象没有引用。但是无法分辨对象间的循环引用。

可达性分析：从栈或静态存储区出发，遍历所有的引用，你将会发现所有"活"的对象。所访问到的对象都是"可达"的，其余对象都是"垃圾"。
注意，这解决了对象间循环引用的问题，这些对象不会被发现，因此也就被自动回收了。java采用这种方法。

2.回收垃圾的方法：

标记-清理(标记-整理)：将可达对象进行标记，回收时直接清空未标记的对象。容易产生内存碎片(标记清理)。为了使内存连续，可以在清理时将存活对象
放在一起(标记整理)，适合存活数据多，垃圾少。

复制：将堆分成两部分，当一半堆内存被分配完之后，将存活对象复制到另一半内存中，清空当前内存。该方法比较简单，但是意味着在一段时间内只能
使用一半内存，会导致内存频繁复制清空，适合存活数据少，垃圾多。

3.java的堆内存结构：
新生代：刚创建的对象会被统一放在一起。因为有很多局部变量等在新创建后很快会变成不可达的对象，快速死去，因此这块区域的特点是存活对象少，垃圾多。

老年代：存活一段时间的对象，它们的特点是存活对象多，垃圾少。

元空间：永久存在的对象，比如一些静态文件，这些对象的特点是不需要垃圾回收，永远存活。

4.java采用的垃圾回收方法：

新生代：存活对象少，垃圾多，采用复制回收机制。由于新生代的对象持续被创建，所以新生代的内存空间要分配的比较大，但是如果比例过大会导致另一部分
内存无法容纳新生代的对象，会有一部分内存移入老年代，导致老年代的对象不是真正的"老年代",为了解决这个问题，java将新生代的内存分为8:1:1。
分别为Eden、Survivor A、Survivor B,Eden存放新生代新创建的对象，Survivor存放经历垃圾回收之后存活的新生代对象。Eden内存最大，存放新创建
的对象，当Eden内存快满之后将进行GC,把存活对象放在Survivor A,清空Eden。当Eden再次快满之后对Eden和Survivor A进行GC,把存活对象放在
Survivor B,同时清空Eden和Survivor A。然后重复操作，即在Eden区填满后，把Eden区和某个Survivor区的存活对象放到另一个Survivor区,
当某个Survivor区被填满，且仍有对象未被复制完毕时，或者某些对象在反复Survive 15 次左右时，则把这部分剩余对象放到Old区。
当 Old 区也被填满时，进行 Major GC，对 Old 区进行垃圾回收

老年代(Old):存活对象多，垃圾少,采用标记-整理回收机制。

### java集合

集合插入顺序：

List：按照插入顺序；

Set：HashSet 使用相当复杂的方法存储元素，是检索元素最快的存储方式，对顺序不重要。TreeSet 按比较结果的升序保存对象，
LinkedHashSet 按照被添加的先后顺序保存对象。
Map：HashMap 对顺序不重要。TreeMap 按比较结果的升序保存对象。LinkedHashMap 在保持 HashMap 查找速度的同时按键的插入顺序保存键。









